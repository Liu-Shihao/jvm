# 一、类加载机制

## 1.1 类加载过程
### 1.1.1 加载
### 1.1.2 连接
1. 校验
2. 准备
    
3. 解析
### 1.1.3 初始化


## 1.2 类加载器



# 二、运行时数据区域（规范）
## 2.1 程序计数器（线程私有）
包含了线程当前运行的位置
线程通过抢占CPU时间片获得执行权

## 2.2 虚拟机栈（线程私有）
### 栈帧
一个方法就是一个栈帧。
栈帧中包含的信息有：
1. 局部变量表
2. 操作数栈
3. 动态链接
4. 返回地址
5. 附加信息
## 2.3 本地方法栈（线程私有）

## 2.4 堆（线程公有）
虚拟机中最大的一块内存，也是垃圾回收的主要区域。
## 2.5 方法区（线程公有）




# 三、对象内存布局
Java对象内存布局分为三部分：对象头、实例信息、对齐信息

## 3.1 对象头
对象头中又包括 MarkWord、ClassPointer、Length（数组对象才有，数组长度）
 1. MarkWord 中包含了对象的hashcode值、锁状态信息、分代年龄；
 2. ClassPointer
 3. 

## 3.2 实例信息
包括类的所有成员变量
1. byte  和 boolean 1字节
2. short 和 char   2字节
3. int   和 float  4字节
4. long  和 double 8字节
5. reference（引用）8字节

但是JVM默认开启指针压缩  所以引用、String占4字节

## 对齐信息
为了保证对象的大小为8的整数倍

# 四、JVM内存模型
JVM运行时数据区是一种规范，而JVM内存模式是对该规范的实现

对堆内存进行划分：
Young 
    Eden  Survivor（ From   To）
Old   

什么时候对象会从新生代进入老年代呢？
对象每经历一次垃圾回收，分代年龄会+1，默认情况下，当年龄到达15的时候，对象会进入到老年区
在对象的内存布局中：对象头信息中包含对象的分代年龄信息 通过 0000 4位二进制表示 所以最大能表示的值为1111 即 15
但是如果对象很大则直接分配到老年代中
还有在GC悲观策略某些情况下，某些对象分代年龄没有达到 直接进入老年代

当Eden区内存不够的时候，会进行一次垃圾回收 Young GC，将对象存放到Survivor 区

为什么要对堆内存进行划分？
因为根据对象的生命周期的分析
有的对象生存时间比较短，有的对象生存时间长


方法区：  类信息  静态变量    常量    即时编译过后的代码    运行时常量池
 jdk1.7 被称为永久区   JVM自己分配的内存
 jdk1.8 改名为元数据区、元空间 Meta Space   使用的是直接内存 Direct Memory  可以动态扩容申请内存

## 对象创建过程
一般情况下，新创建的对象都会被分配到`Eden区`，一些特殊的大的对象会直接分配到`Old区`。



